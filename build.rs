use std::path::PathBuf;
use std::process::Command;

fn build_mod_content(generated_files: &[(String, String)]) -> String {
    let mut content = String::new();
    content.push_str("// Auto-generated module file for TensorBoard protobuf bindings\n");
    content.push_str("// This file is generated by build.rs - do not edit manually\n\n");

    // Handle google.protobuf specially
    if let Some((file_name, module_name)) =
        generated_files.iter().find(|(f, _)| f == "google.protobuf")
    {
        content.push_str(&format!("#[path = \"{}.rs\"]\n", file_name));
        content.push_str(&format!("mod {};\n\n", module_name));
        content.push_str("pub mod google {\n");
        content.push_str("    pub mod protobuf {\n");
        content.push_str(&format!(
            "        pub use super::super::{}::*;\n",
            module_name
        ));
        content.push_str("    }\n");
        content.push_str("}\n\n");
    }

    // Add regular module declarations
    for (file_name, module_name) in generated_files {
        if file_name == "google.protobuf" {
            continue; // Already handled above
        }
        content.push_str(&format!(
            "#[path = \"{}.rs\"]\npub mod {};\n",
            file_name, module_name
        ));
    }

    content
}

fn generate_mod_file(generated_dir: &PathBuf) -> Result<(), Box<dyn std::error::Error>> {
    let generated_files = std::fs::read_dir(generated_dir)?
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "rs" && path.file_name()? != "mod.rs" {
                let stem = path.file_stem()?.to_str()?;
                Some((stem.to_string(), stem.replace(".", "_")))
            } else {
                None
            }
        })
        .collect::<Vec<_>>();
    let mod_content = build_mod_content(&generated_files);

    let mod_rs_path = generated_dir.join("mod.rs");
    std::fs::write(&mod_rs_path, mod_content)?;

    println!(
        "Generated mod.rs with {} module declarations",
        generated_files.len()
    );
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=scripts/download_tensorboard_protos.sh");

    // Download TensorBoard protos
    let output = Command::new("bash")
        .arg("scripts/download_tensorboard_protos.sh")
        .output()
        .expect("Failed to execute download script");
    if !output.status.success() {
        panic!(
            "Failed to download TensorBoard protos: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    // Generate protobuf bindings
    let generated_dir = PathBuf::from("./src/tensorboard_generated");
    let tensorboard_dir = PathBuf::from("/tmp/tensorboard");
    let proto_path = tensorboard_dir
        .join("tensorboard")
        .join("compat")
        .join("proto");

    if !proto_path.exists() {
        panic!("Proto directory does not exist: {}", proto_path.display());
    }

    // Find all .proto files
    let proto_files = std::fs::read_dir(&proto_path)?
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "proto" {
                Some(path)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    if proto_files.is_empty() {
        panic!("No .proto files found in {}", proto_path.display());
    }

    println!(
        "Found {} proto files in {}",
        proto_files.len(),
        proto_path.display()
    );

    // Setup prost-build and compile
    std::fs::create_dir_all(&generated_dir)?;
    let mut prost_build = prost_build::Config::new();
    prost_build
        .out_dir(&generated_dir)
        .compile_well_known_types()
        .compile_protos(&proto_files, &[&tensorboard_dir])?;

    println!(
        "Generated protobuf bindings for {} files",
        proto_files.len()
    );

    // Generate mod.rs file
    generate_mod_file(&generated_dir)?;

    Ok(())
}
