use std::path::PathBuf;
use std::process::Command;

// File paths and directories
const DOWNLOAD_SCRIPT_PATH: &str = "../scripts/download_tensorboard_protos.sh";
const GENERATED_DIR: &str = "src/tensorboard_generated";
const TENSORBOARD_TMP_DIR: &str = "/tmp/tensorboard";
const PROTO_SUBPATH: &[&str] = &["tensorboard", "compat", "proto"];
const MOD_FILE_NAME: &str = "mod.rs";

fn dedent(input: &str) -> String {
    let lines: Vec<&str> = input.lines().collect();
    let min_indent = lines
        .iter()
        .filter_map(|line| {
            if line.trim().is_empty() {
                None
            } else {
                Some(line.chars().take_while(|c| *c == ' ').count())
            }
        })
        .min()
        .unwrap_or(0);
    let mut out = String::new();
    for (i, line) in lines.iter().enumerate() {
        if line.len() >= min_indent {
            out.push_str(&line[min_indent..]);
        } else {
            out.push_str(line);
        }
        if i + 1 < lines.len() {
            out.push('\n');
        }
    }
    out
}

fn build_mod_content(generated_files: &[(String, String)]) -> String {
    let mut sections: Vec<String> = vec![
        dedent(
            r#"
            // Auto-generated module file for TensorBoard protobuf bindings
            // This file is generated by build.rs - do not edit manually
        "#,
        ) + "\n\n",
    ];

    if let Some((file_name, module_name)) =
        generated_files.iter().find(|(f, _)| f == "google.protobuf")
    {
        sections.push(
            dedent(&format!(
                r#"
                #[path = "{file_name}.rs"]
                mod {module_name};

                pub mod google {{
                    pub mod protobuf {{
                        pub use super::super::{module_name}::*;
                    }}
                }}
            "#
            )) + "\n\n",
        );
    }

    for (file_name, module_name) in generated_files {
        if file_name == "google.protobuf" {
            continue;
        }
        sections.push(
            dedent(&format!(
                r#"
                #[path = "{file_name}.rs"]
                pub mod {module_name};
            "#
            )) + "\n\n",
        );
    }

    sections.join("")
}

fn generate_mod_file(generated_dir: &PathBuf) -> Result<(), Box<dyn std::error::Error>> {
    let generated_files = std::fs::read_dir(generated_dir)?
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "rs" && path.file_name()? != MOD_FILE_NAME {
                let stem = path.file_stem()?.to_str()?;
                Some((stem.to_string(), stem.replace(".", "_")))
            } else {
                None
            }
        })
        .collect::<Vec<_>>();
    let mod_content = build_mod_content(&generated_files);

    let mod_rs_path = generated_dir.join(MOD_FILE_NAME);
    std::fs::write(&mod_rs_path, mod_content)?;
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed={}", DOWNLOAD_SCRIPT_PATH);

    let output = Command::new("bash")
        .arg(DOWNLOAD_SCRIPT_PATH)
        .output()
        .expect("Failed to execute download script");
    if !output.status.success() {
        panic!(
            "Failed to download TensorBoard protos: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    let generated_dir = PathBuf::from(GENERATED_DIR);
    let tensorboard_dir = PathBuf::from(TENSORBOARD_TMP_DIR);
    let proto_path = PROTO_SUBPATH
        .iter()
        .fold(tensorboard_dir.clone(), |path, segment| path.join(segment));
    if !proto_path.exists() {
        panic!("Proto directory does not exist: {}", proto_path.display());
    }

    let proto_files = std::fs::read_dir(&proto_path)?
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.extension()? == "proto" {
                Some(path)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();
    if proto_files.is_empty() {
        panic!("No .proto files found in {}", proto_path.display());
    }

    std::fs::create_dir_all(&generated_dir)?;
    let mut prost_build = prost_build::Config::new();
    prost_build
        .out_dir(&generated_dir)
        .compile_well_known_types()
        .compile_protos(&proto_files, &[&tensorboard_dir])?;

    generate_mod_file(&generated_dir)?;
    Ok(())
}
